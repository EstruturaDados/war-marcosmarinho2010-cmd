#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define TAM_FILA 5   // Tamanho fixo da fila de pe√ßas

/*
    ===========================================================
    PROGRAMA: Tetris Stack - Simula√ß√£o de Fila de Pe√ßas Futuras
    AUTOR: Morgano (ChatGPT)
    ===========================================================

    OBJETIVO:
        Simular a estrutura de controle das pe√ßas do jogo Tetris Stack,
        utilizando uma FILA circular para gerenciar a entrada e sa√≠da de pe√ßas.

    CONCEITOS UTILIZADOS:
        - Structs
        - Fila circular (enqueue e dequeue)
        - Gera√ß√£o aleat√≥ria de dados (rand)
        - Modulariza√ß√£o (fun√ß√µes)
        - Intera√ß√£o com o usu√°rio (menu simples)
*/

// ------------------- Estrutura de Dados ---------------------

typedef struct {
    char tipo;  // Tipo da pe√ßa ('I', 'O', 'T', 'L')
    int id;     // Identificador √∫nico da pe√ßa
} Peca;

typedef struct {
    Peca pecas[TAM_FILA];  // Vetor que armazena as pe√ßas
    int inicio;             // √çndice do in√≠cio da fila
    int fim;                // √çndice do final da fila
    int qtd;                // Quantidade atual de pe√ßas na fila
} Fila;

// ------------------- Prot√≥tipos das Fun√ß√µes -----------------

void inicializarFila(Fila *f);
int filaCheia(const Fila *f);
int filaVazia(const Fila *f);
void enfileirar(Fila *f, Peca nova);
Peca desenfileirar(Fila *f);
Peca gerarPeca(int id);
void exibirFila(const Fila *f);
void limparBuffer();

// ------------------- Implementa√ß√£o das Fun√ß√µes ---------------

// Inicializa os valores da fila
void inicializarFila(Fila *f) {
    f->inicio = 0;
    f->fim = -1;
    f->qtd = 0;
}

// Verifica se a fila est√° cheia
int filaCheia(const Fila *f) {
    return f->qtd == TAM_FILA;
}

// Verifica se a fila est√° vazia
int filaVazia(const Fila *f) {
    return f->qtd == 0;
}

// Insere nova pe√ßa no final da fila (enqueue)
void enfileirar(Fila *f, Peca nova) {
    if (filaCheia(f)) {
        printf("\n‚ö†Ô∏è  A fila est√° cheia! N√£o √© poss√≠vel adicionar nova pe√ßa.\n");
        return;
    }
    f->fim = (f->fim + 1) % TAM_FILA;
    f->pecas[f->fim] = nova;
    f->qtd++;
}

// Remove pe√ßa do in√≠cio da fila (dequeue)
Peca desenfileirar(Fila *f) {
    Peca removida = {'-', -1};

    if (filaVazia(f)) {
        printf("\n‚ö†Ô∏è  A fila est√° vazia! N√£o h√° pe√ßa para jogar.\n");
        return removida;
    }

    removida = f->pecas[f->inicio];
    f->inicio = (f->inicio + 1) % TAM_FILA;
    f->qtd--;
    return removida;
}

// Gera uma nova pe√ßa com tipo aleat√≥rio e ID incremental
Peca gerarPeca(int id) {
    char tipos[] = {'I', 'O', 'T', 'L'};
    Peca p;
    p.tipo = tipos[rand() % 4];
    p.id = id;
    return p;
}

// Exibe o estado atual da fila
void exibirFila(const Fila *f) {
    printf("\n===== FILA DE PE√áAS FUTURAS =====\n");
    if (filaVazia(f)) {
        printf("(Fila vazia)\n");
        return;
    }

    int i, idx;
    for (i = 0; i < f->qtd; i++) {
        idx = (f->inicio + i) % TAM_FILA;
        printf("[%c %d] ", f->pecas[idx].tipo, f->pecas[idx].id);
    }
    printf("\n");
}

// Limpa o buffer do teclado
void limparBuffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

// ------------------- Fun√ß√£o Principal ------------------------

int main() {
    Fila fila;
    inicializarFila(&fila);
    srand(time(NULL));

    int idGlobal = 0;
    int opcao;
    Peca jogada;

    // Preenche a fila inicialmente com 5 pe√ßas
    for (int i = 0; i < TAM_FILA; i++) {
        enfileirar(&fila, gerarPeca(idGlobal++));
    }

    printf("=== TETRIS STACK - SISTEMA DE FILA DE PE√áAS ===\n");

    do {
        exibirFila(&fila);
        printf("\nOp√ß√µes:\n");
        printf("1 - Jogar pe√ßa (dequeue)\n");
        printf("2 - Inserir nova pe√ßa (enqueue)\n");
        printf("0 - Sair\n");
        printf("Escolha uma op√ß√£o: ");
        scanf("%d", &opcao);
        limparBuffer();

        switch (opcao) {
            case 1:
                jogada = desenfileirar(&fila);
                if (jogada.id != -1)
                    printf("üéÆ Pe√ßa [%c %d] jogada!\n", jogada.tipo, jogada.id);
                break;

            case 2:
                enfileirar(&fila, gerarPeca(idGlobal++));
                printf("‚ûï Nova pe√ßa adicionada √† fila!\n");
                break;

            case 0:
                printf("\nEncerrando o jogo... üëã\n");
                break;

            default:
                printf("Op√ß√£o inv√°lida! Tente novamente.\n");
        }

    } while (opcao != 0);

    return 0;
}
